# FilterQL Spring Adapter

**Version:** 4.0.0  
**Java:** 17+  
**Spring Boot:** 3.3.5+

Spring Boot integration module providing annotation processing, service layer abstraction, and REST controller generation for FilterQL.

---

## Important Note

This module provides **integration** components that work with external annotations from the [Projection Specification](https://github.com/cyfko/projection-spec).

**Architecture:**
- **[projection-spec](https://github.com/cyfko/projection-spec)**: Defines annotations (`@Projection`, `@Provider`, `@Projected`, `@Computed`, `@MethodReference`)
- **[projection-metamodel-processor](https://github.com/cyfko/jpa-metamodel-processor)**: Implements the spec, generates `PersistenceRegistry` and `ProjectionRegistry`
- **filterql-spring**: CONSUMES the external `@Projection` annotation and generates FilterQL-specific components

**What FilterQL Spring provides:**
- `@Exposure` and `@ExposedAs` annotations (defined in this module)
- `ExposureAnnotationProcessor` (processes `@Projection` annotations from external library)
- `FilterQlService` implementation
- Code generators for PropertyRef enums and Spring configuration
- `PaginatedData` wrapper for results
- `FilterContextRegistry` for context management

**What comes from external dependencies:**
- `@Projection` annotation → from [projection-spec](https://github.com/cyfko/projection-spec) / [projection-metamodel-processor:1.0.0](https://github.com/cyfko/jpa-metamodel-processor)
- `@Provider`, `@Projected`, `@Computed` → from projection-spec
- `PersistenceRegistry`, `ProjectionRegistry` → generated by projection-metamodel-processor

---

## Architecture

FilterQL Spring acts as a bridge between:
1. External annotation processor (`projection-metamodel-processor`)
2. FilterQL Core/JPA modules
3. Spring Boot ecosystem

```
External Library                      FilterQL Spring                     Spring Boot App
┌─────────────────────┐             ┌──────────────────────┐             ┌─────────────┐
│                     │             │                      │             │             │
│  @Projection        │────reads───>│ Exposure             │─generates──>│ Generated   │
│  (external def)     │             │ AnnotationProcessor  │             │ Enum + Bean │
│                     │             │                      │             │             │
│  @Provider          │             │ PropertyRefEnum      │             │ Filter      │
│  (external def)     │             │ Generator            │             │ ContextCon  │
│                     │             │                      │             │ fig         │
└─────────────────────┘             │ FilterContext        │             │             │
                                     │ Generator            │             │ FilterQl    │
FilterQL Spring defines:            │                      │             │ Controller  │
┌─────────────────────┐             │ FilterController     │             │             │
│  @Exposure          │────used────>│ Generator            │             └─────────────┘
│  @ExposedAs         │  by         │                      │
│                     │             └──────────────────────┘
└─────────────────────┘                       │
                                              │ uses
                                              v
                                  ┌──────────────────────┐
                                  │                      │
                                  │  FilterQlService     │
                                  │  PaginatedData       │
                                  │  ResultMapper        │
                                  │  FilterContextReg    │
                                  │                      │
                                  └──────────────────────┘
```

---

## Module Components

### 1. Annotations (Defined in this module)

#### @Exposure
**Package:** `io.github.cyfko.filterql.spring`  
**Purpose:** Marks a projection class for REST controller generation  
**Used with:** External `@Projection` annotation

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface Exposure {
    String value() default "";         // REST resource name (kebab-case)
    String basePath() default "";      // URI path prefix
    MethodReference annotationsFrom() default @MethodReference(); // Method reference for endpoint annotations
}
```

#### @ExposedAs
**Package:** `io.github.cyfko.filterql.spring`  
**Purpose:** Customizes field exposure in generated enum  
**Used with:** External `@Projected` annotation

```java
@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.SOURCE)
public @interface ExposedAs {
    String value();              // Symbolic name in enum
    Op[] operators() default {}; // Supported operators
    boolean exposed() default true;
}
```

### 2. Annotation Processor

#### ExposureAnnotationProcessor
**Package:** `io.github.cyfko.filterql.spring.processor`  
**Annotation Processed:** `io.github.cyfko.projection.Projection` (external)  
**Generated Artifacts:**
- PropertyRef enum (`{ClassName}_`)
- `FilterQlContextConfig` (Spring configuration)
- `FilterQlController` (REST endpoints)

**Processing Flow:**
```java
@SupportedAnnotationTypes("io.github.cyfko.projection.Projection")
public class ExposureAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // 1. Find classes annotated with @Projection (external annotation)
        // 2. Analyze fields using FieldAnalyzer
        // 3. Generate PropertyRef enum via PropertyRefEnumGenerator
        // 4. Generate FilterContext bean via FilterContextGenerator
        // 5. Generate REST controller via FilterControllerGenerator (if @Exposure present)
    }
}
```

**Key Dependencies:**
- `FieldAnalyzer` - extracts field metadata from `@Projected` fields
- `PropertyRefEnumGenerator` - generates PropertyRef enum from template
- `FilterContextGenerator` - generates Spring `@Configuration` class
- `FilterControllerGenerator` - generates REST controller (if `@Exposure` used)

### 3. Code Generators

#### PropertyRefEnumGenerator
**Template:** `property-ref-enum.java.tpl`  
**Generates:** Type-safe PropertyReference enum

**Generated Structure:**
```java
public enum PersonDTO_ implements PropertyReference {
    USERNAME, EMAIL, AGE;
    
    @Override
    public Class<?> getType() {
        var pm = ProjectionRegistry.getMetadataFor(PersonDTO.class);
        return switch(this) {
            case USERNAME -> pm.getDirectMapping("username", true).get().dtoFieldType();
            case EMAIL -> pm.getDirectMapping("email", true).get().dtoFieldType();
            case AGE -> pm.getDirectMapping("age", true).get().dtoFieldType();
        };
    }
    
    @Override
    public Set<Op> getSupportedOperators() {
        return switch(this) {
            case USERNAME -> Set.of(Op.EQ, Op.MATCHES, Op.IN);
            case EMAIL -> Set.of(Op.EQ, Op.MATCHES);
            case AGE -> Set.of(Op.EQ, Op.GT, Op.LT, Op.GTE, Op.LTE);
        };
    }
    
    @Override
    public Class<?> getEntityType() {
        return Person.class;
    }
}
```

#### FilterContextGenerator
**Templates:** `filter-context-instance.java.tpl`, `filter-context-config.java.tpl`  
**Generates:** Spring `@Configuration` class with `JpaFilterContext` beans

**Generated Structure:**
```java
@Configuration
public class FilterQlContextConfig {
    
    @Bean
    public JpaFilterContext<?> personDTOContext(InstanceResolver instanceResolver) {
        return new JpaFilterContext<>(PersonDTO_.class, (ref) -> switch (ref) {
            case USERNAME -> "username";  // Simple path mapping
            case EMAIL -> "email";
            case FULL_NAME -> PersonDTO.fullNameMatches();  // Virtual field returns PredicateResolverMapping
            // ... other cases
        });
    }
}
```

**Note:** The second parameter is a `Function<P, Object>` that returns:
- `String` for direct JPA path mapping (e.g., `"username"`, `"address.city"`)
- `PredicateResolverMapping<E>` for custom logic (e.g., virtual fields)

#### FilterControllerGenerator
**Templates:** `search-controller.java.tpl`, `search-endpoint.java.tpl`  
**Generates:** REST controller with search endpoints

**Generated Structure:**
```java
@RestController
public class FilterQlController {
    
    @Autowired
    private FilterQlService filterQlService;
    
    @PostMapping("/api/v1/users/search")
    public ResponseEntity<PaginatedData<Map<String, Object>>> searchPersonDTO(
        @RequestBody @Validated FilterRequest<PersonDTO_> request
    ) {
        return ResponseEntity.ok(filterQlService.search(PersonDTO_.class, request));
    }
}
```

### 4. Service Layer

#### FilterQlService
**Package:** `io.github.cyfko.filterql.spring.service`  
**Implementation:** `FilterQlServiceImpl`

```java
public interface FilterQlService {
    <P extends Enum<P> & PropertyReference> 
    PaginatedData<Map<String,Object>> search(
        Class<P> refClass, 
        FilterRequest<P> filterRequest
    );
    
    <R,P extends Enum<P> & PropertyReference> 
    PaginatedData<R> search(
        Class<R> projectionClass, 
        FilterRequest<P> filterRequest, 
        ResultMapper<R> resultMapper
    );
}
```

**Implementation Details:**
```java
@Service
public class FilterQlServiceImpl implements FilterQlService {
    @PersistenceContext
    private EntityManager em;
    
    private final FilterContextRegistry contextRegistry;
    private final InstanceResolver instanceResolver;
    
    @Override
    public <P extends Enum<P> & PropertyReference>
    PaginatedData<Map<String,Object>> search(Class<P> refClass, FilterRequest<P> filterRequest) {
        // 1. Derive projection class from enum name (PersonDTO_ -> PersonDTO)
        Class<?> projectionClass = toProjectionClass(refClass);
        
        // 2. Get FilterContext from registry
        JpaFilterContext<?> context = contextRegistry.getContext(refClass);
        
        // 3. Execute with MultiQueryFetchStrategy
        MultiQueryFetchStrategy strategy = new MultiQueryFetchStrategy(projectionClass, instanceResolver);
        List<Map<String, Object>> results = FilterQueryFactory.of(context)
            .execute(filterRequest, em, strategy);
        
        // 4. Count total matches
        Long counted = FilterQueryFactory.of(context)
            .execute(filterRequest, em, new CountStrategy(projectionClass));
        
        // 5. Build PaginatedData
        int page = filterRequest.hasPagination() ? filterRequest.pagination().page() : 0;
        PaginationInfo pagination = new PaginationInfo(page, results.size(), counted);
        
        return new PaginatedData<>(results, pagination);
    }
}
```

### 5. Pagination

#### PaginatedData
**Package:** `io.github.cyfko.filterql.spring.pagination`

```java
public record PaginatedData<T>(
    List<T> data,
    PaginationInfo pagination
) {
    public PaginatedData(List<T> data, PaginationInfo pagination) {
        this.data = List.copyOf(data);
        this.pagination = pagination;
    }
    
    public PaginatedData(Page<T> page) {
        this(page.getContent(), PaginationInfo.from(page));
    }
    
    public <R> PaginatedData<R> map(Function<T, R> mapper) {
        return new PaginatedData<>(data.stream().map(mapper).collect(Collectors.toList()), pagination);
    }
}
```

#### PaginationInfo
```java
public record PaginationInfo(
    int currentPage,
    int pageSize,
    long totalElements
) {
    public int totalPages() {
        return (int) Math.ceil((double) totalElements / pageSize);
    }
    
    public static PaginationInfo from(Page<?> page) {
        return new PaginationInfo(
            page.getNumber(),
            page.getSize(),
            page.getTotalElements()
        );
    }
}
```

### 6. Support Components

#### FilterContextRegistry
**Package:** `io.github.cyfko.filterql.spring.support`  
**Purpose:** Central registry for all `JpaFilterContext` beans

```java
@Component
public class FilterContextRegistry {
    private final Map<Class<?>, JpaFilterContext<?>> contextByEnum;
    
    public FilterContextRegistry(List<JpaFilterContext<?>> contexts) {
        this.contextByEnum = new HashMap<>();
        for (JpaFilterContext<?> context : contexts) {
            contextByEnum.put(context.getPropertyRefClass(), context);
        }
    }
    
    public <P extends Enum<P> & PropertyReference> 
    JpaFilterContext<?> getContext(Class<P> enumClass) {
        JpaFilterContext<?> context = contextByEnum.get(enumClass);
        if (context == null) {
            throw new IllegalArgumentException(
                "No JpaFilterContext found for reference " + enumClass.getName() + 
                ". Ensure @Projection is used."
            );
        }
        return context;
    }
}
```

#### SpringProviderResolver
**Package:** `io.github.cyfko.filterql.spring.service.impl`  
**Purpose:** Resolves computed field providers from Spring context

```java
@Component
public class SpringProviderResolver implements InstanceResolver {
    private final ApplicationContext applicationContext;
    
    public SpringProviderResolver(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    
    @Override
    public <T> T resolve(Class<T> providerClass) {
        return applicationContext.getBean(providerClass);
    }
}
```

### 7. Auto-Configuration

#### FilterQlAutoConfiguration
**Package:** `io.github.cyfko.filterql.spring.autoconfigure`

```java
@Configuration
@ConditionalOnClass(JpaFilterContext.class)
@EnableConfigurationProperties(FilterQlProperties.class)
public class FilterQlAutoConfiguration {
    @Bean
    public FilterContextRegistry filterContextRegistry(List<JpaFilterContext<?>> contexts) {
        return new FilterContextRegistry(contexts);
    }
}
```

---

## Usage Example

### Step 1: Add Dependencies

**pom.xml:**
```xml
<dependencies>
    <!-- FilterQL Spring -->
    <dependency>
        <groupId>io.github.cyfko</groupId>
        <artifactId>filterql-spring</artifactId>
        <version>4.0.0</version>
    </dependency>
    
    <!-- FilterQL JPA Adapter -->
    <dependency>
        <groupId>io.github.cyfko</groupId>
        <artifactId>filterql-adapter-jpa</artifactId>
        <version>2.0.0</version>
    </dependency>
    
    <!-- External Projection Processor (implements projection-spec) -->
    <!-- See: https://github.com/cyfko/jpa-metamodel-processor -->
    <dependency>
        <groupId>io.github.cyfko</groupId>
        <artifactId>projection-metamodel-processor</artifactId>
        <version>1.0.0</version>
    </dependency>
    
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

### Step 2: Define Entity

```java
@Entity
@Table(name = "persons")
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String email;
    
    private Integer age;
    
    // Getters/Setters
}
```

### Step 3: Define Projection with External Annotations

**Annotation Sources:**
- `@Projection`, `@Projected` → from [projection-spec](https://github.com/cyfko/projection-spec)
- `@Exposure`, `@ExposedAs` → from FilterQL Spring (this module)

```java
// External: projection-spec annotations
import io.github.cyfko.projection.Projection;
import io.github.cyfko.projection.Projected;

// FilterQL Spring annotations
import io.github.cyfko.filterql.spring.Exposure;
import io.github.cyfko.filterql.spring.ExposedAs;
import io.github.cyfko.filterql.core.api.Op;

@Projection(from = Person.class)
@Exposure(value = "users", basePath = "/api/v1")
public class PersonDTO {
    
    @Projected
    @ExposedAs(value = "USERNAME", operators = {Op.EQ, Op.MATCHES, Op.IN})
    private String username;
    
    @Projected
    @ExposedAs(value = "EMAIL", operators = {Op.EQ, Op.MATCHES})
    private String email;
    
    @Projected
    @ExposedAs(value = "AGE", operators = {Op.EQ, Op.GT, Op.LT, Op.GTE, Op.LTE})
    private Integer age;
    
    // Getters/Setters
}
```

### Step 4: Build Project

Annotation processor runs at compile time:

```bash
mvn clean compile
```

**Generated Files:**
- `PersonDTO_.java` - PropertyRef enum
- `FilterQlContextConfig.java` - Spring configuration with `personDTOContext` bean
- `FilterQlController.java` - REST controller with `/api/v1/users/search` endpoint

### Step 5: Use Generated Endpoint

**Request Body Structure:**

The generated endpoint accepts a `FilterRequest` object with the following structure:

```json
{
  "filters": {
    "usernameFilter": {
      "ref": "USERNAME",
      "op": "MATCHES",
      "value": "john%"
    },
    "ageFilter": {
      "ref": "AGE",
      "op": "GT",
      "value": 25
    }
  },
  "combineWith": "usernameFilter & ageFilter",
  "pagination": {
    "page": 0,
    "size": 20,
    "sort": [
      {
        "field": "age",
        "direction": "DESC"
      }
    ]
  }
}
```

**Example Request:**

```bash
curl -X POST http://localhost:8080/api/v1/users/search \
  -H "Content-Type: application/json" \
  -d '{
    "filters": {
      "f1": {"ref": "USERNAME", "op": "MATCHES", "value": "john%"},
      "f2": {"ref": "AGE", "op": "GT", "value": 25}
    },
    "combineWith": "f1 & f2",
    "pagination": {
      "page": 0,
      "size": 20,
      "sort": [{"field": "age", "direction": "DESC"}]
    }
  }'
```

**Simpler Request (without filters):**

```bash
curl -X POST http://localhost:8080/api/v1/users/search \
  -H "Content-Type: application/json" \
  -d '{
    "pagination": {
      "page": 0,
      "size": 20
    }
  }'
```

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "username": "john.doe",
      "email": "john@example.com",
      "age": 30
    }
  ],
  "pagination": {
    "currentPage": 0,
    "pageSize": 20,
    "totalElements": 1,
    "totalPages": 1
  }
}
```

**Collection Projection with Pagination & Sorting:**

```bash
curl -X POST http://localhost:8080/api/v1/authors/search \
  -H "Content-Type: application/json" \
  -d '{
    "filters": {
      "f1": {"ref": "NAME", "op": "MATCHES", "value": "%smith%"}
    },
    "combineWith": "f1",
    "projection": [
      "id",
      "name",
      "books[size=10,sort=year:desc].title,year",
      "awards[size=5].name"
    ],
    "pagination": {
      "page": 0,
      "size": 20,
      "sort": [{"field": "name", "direction": "ASC"}]
    }
  }'
```

**Projection Syntax:**
- `collection[size=N]` - Limit collection to N items
- `collection[page=P]` - Fetch page P (0-indexed)
- `collection[sort=field:dir]` - Sort by field (asc/desc)
- `collection[size=10,page=0,sort=year:desc]` - Combined options
- `prefix.field1,field2,field3` - Multi-field with shared prefix

See [FilterQL Core Documentation](../../core/java/README.md#projection-field-syntax) for complete projection syntax reference.

### Step 6: Use Service Programmatically

```java
@RestController
@RequestMapping("/api/custom")
public class CustomController {
    
    @Autowired
    private FilterQlService filterQlService;
    
    @PostMapping("/users/advanced")
    public PaginatedData<UserSummary> advancedSearch(
        @RequestBody FilterRequest<PersonDTO_> request
    ) {
        return filterQlService.search(
            UserSummary.class,
            request,
            row -> new UserSummary(
                (String) row.get("username"),
                (String) row.get("email")
            )
        );
    }
}
```

---

## Template System

### Available Templates

Located in `src/main/resources/templates/`:

1. **property-ref-enum.java.tpl** - PropertyRef enum generation
2. **filter-context-instance.java.tpl** - Individual FilterContext bean
3. **filter-context-config.java.tpl** - Spring configuration class wrapper
4. **search-controller.java.tpl** - REST controller wrapper
5. **search-endpoint.java.tpl** - Individual search endpoint method

### Template Variables

**property-ref-enum.java.tpl:**
- `${packageName}` - Package declaration
- `${enumName}` - Enum class name
- `${constants}` - Enum constant declarations
- `${enumToFieldTypeSwitch}` - Type resolution switch
- `${enumToOperatorsSwitch}` - Operator mapping switch
- `${entityClass}` - Entity class literal

**filter-context-instance.java.tpl:**
- `${propertyRefEnumName}` - Full qualified enum name
- `${beanName}` - Bean method name
- `${contextParam}` - Additional constructor parameters (InstanceResolver if virtual fields)
- `${switchCases}` - Switch cases for predicate resolution

**search-endpoint.java.tpl:**
- `${basePath}` - Base path for endpoint
- `${exposedName}` - Resource name
- `${listItemType}` - Response item type
- `${methodName}` - Method name
- `${fqEnumName}` - Fully qualified enum name
- `${annotationDecorators}` - Additional annotations (@PreAuthorize, @Cacheable, etc.)

---

## Dependencies

**Required:**
- `filterql-adapter-jpa:2.0.0` (provided scope)
- `projection-metamodel-processor:1.0.0` (provided scope - external library)
- `spring-boot-starter-data-jpa:3.3.5`
- `spring-boot-starter-web:3.3.5`
- `spring-context:6.1.x`
- `auto-service:1.1.1` (optional)

**Transitive:**
- `filterql-core:4.0.0` (via filterql-jpa)
- Jakarta Persistence API 3.1+
- Hibernate 6.x

---

## Configuration

### application.yml

Currently no configuration properties are used (FilterQlProperties exists but unused).

---

## Limitations

### 1. External Annotation Dependency

**Constraint:** Requires [projection-spec](https://github.com/cyfko/projection-spec) annotations and [projection-metamodel-processor:1.0.0](https://github.com/cyfko/jpa-metamodel-processor) implementation.

**Impact:**
- Cannot use filterql-spring without these external dependencies
- `@Projection` annotation must be present on DTO classes
- Generated code references external `ProjectionRegistry` and `PersistenceRegistry` classes
- Must follow projection-spec semantics for computed fields and providers

### 2. Enum Naming Convention

**Constraint:** Generated PropertyRef enums are named `{ClassName}_` (e.g., `PersonDTO_`).

**Impact:** This naming convention is hardcoded and cannot be customized.

### 3. Single Source Per Projection

**Constraint:** Each `@Projection` class maps to exactly one source class.

**Impact:** Cannot create unions or joins of multiple sources in a single projection.

### 4. Return Type Restriction

**Constraint:** `FilterQlService.search()` returns `PaginatedData<Map<String, Object>>` or `PaginatedData<R>` with mapper.

**Impact:** Cannot return raw entities or Spring Data Page objects directly.

### 5. Template Customization

**Constraint:** Templates are bundled in JAR (`src/main/resources/templates/`).

**Impact:** Cannot override templates without recompiling the module.

### 6. Package Structure

**Constraint:** Generated classes use fixed package structure:
- Config: `io.github.cyfko.filterql.spring.config`
- Controller: `io.github.cyfko.filterql.spring.controller`
- Enums: Same package as projection class

**Impact:** Cannot customize generated package locations.

---

## Known Issues

### Issue: InstanceResolver Not Found

**Symptom:** `NoSuchBeanDefinitionException: No qualifying bean of type 'InstanceResolver'`

**Cause:** Missing `SpringProviderResolver` bean (should be auto-configured)

**Solution:** Ensure `filterql-spring` is in component scan path

### Issue: Generated Classes Not Found

**Symptom:** Compilation errors for `PersonDTO_` enum

**Solution:** Run `mvn clean compile` to trigger annotation processing

### Issue: Multiple @Projection Processors

**Symptom:** Conflict between external processor and `ExposureAnnotationProcessor`

**Solution:** Both processors can coexist (`ExposureAnnotationProcessor.process()` returns `false`)

---

## See Also

**FilterQL Modules:**
- [FilterQL Core Documentation](../../core/java/README.md)
- [FilterQL JPA Adapter Documentation](../filterql-jpa/README.md)
- [FilterQL Spring Starter Documentation](../filterql-spring-starter/README.md)
- [Integration Tests Documentation](../../integration-test/README.md)
- [Main README](../../README.md)

**External Dependencies:**
- [Projection Specification](https://github.com/cyfko/projection-spec) - Annotation specification for DTO projections
- [Projection Metamodel Processor](https://github.com/cyfko/jpa-metamodel-processor) - Annotation processor implementation
- [Maven Central: projection-metamodel-processor](https://search.maven.org/artifact/io.github.cyfko/jpa-metamodel-processor)

---

## License

Licensed under the MIT License. See [LICENSE](../../LICENSE) for details.
